#
# Special Forms
#   (break value?)
#   (def name meta... value)
#   (do body...)
#   (fn name? args body...)
#   (if condition when-true when-false?)
#   (quasiquote x)
#   (quote x)
#   (set l-value r-value)
#   (splice x)
#   (unquote x)
#   (upscope & body)
#   (var name meta... value)
#   (while condition body...)
#
# Functions
#   %
#   *
#   +
#   -
#   /
#   accumulate
#   accumulate2
#   all
#   apply
#   array?
#   array/concat
#   asm
#   boolean?
#   buffer?
#   bytes?
#   cfunction?
#   comp
#   compare
#   complement
#   count
#   dec
#   dictionary?
#   drop
#   drop-until
#   drop-while
#   empty?
#   eval-string
#   eval
#   even?
#   extreme
#   fiber?
#   filter
#   find
#   find-index
#   first
#   function?
#   has-key?
#   has-value?
#   identity
#   inc
#   index-of
#   indexed?
#   interpose
#   juxt*
#   keep
#   keyword?
#   last
#   map
#   mapcat
#   max
#   max-of
#   mean
#   min
#   min-of
#   nan?
#   neg?
#   number?
#   odd?
#   one?
#   os/strftime
#   pos?
#   product
#   range
#   reduce
#   reverse
#   slice
#   some
#   sort
#   sort-by
#   sorted
#   string/split
#   string/trim
#   string/triml
#   string/trimr
#   string?
#   struct?
#   sum
#   symbol?
#   table?
#   take
#   take-until
#   take-while
#   tuple?
#   type
#   zero?
#
# Macros
#   %=
#   *=
#   ++
#   +=
#   --
#   -=
#   /=
#   and
#   assert
#   case
#   chr
#   comment
#   cond
#   coro
#   default
#   defdyn
#   defer
#   defn
#   each
#   eachk
#   eachp
#   edefer
#   errorf
#   for
#   forever
#   forv
#   generate
#   if-let
#   if-not
#   if-with
#   juxt
#   label
#   let
#   loop
#   or
#   prompt
#   protect
#   repeat
#   return
#   seq
#   short-fn
#   tabseq
#   toggle
#   try
#   unless
#   when
#   when-let
#   when-with
#   with
#   with-syms
#
# Variables
#   default-peg-grammar
#
# Dynamic Variables
#   *out*
